---
description: Use this rule when asked to create or edit a marimo notebook in this repo
alwaysApply: false
---

## Notebook Structure and Cell Organization

### Required Cells (MUST be present in every notebook):
- **Setup Cell**: always start with the `setup_pyoso` cell (exact logic below)
- **Documentation Cell**: use `about_app` cell with vstack pattern

### Common Reusable Building Blocks (use as needed):
- **Configuration Cell**: constants, layouts, reusable configs
- **Data Cells**: fetch and process data in dedicated cells
- **Visualization Cells**: group related charts together; keep clean separation
- **UI Cells**: isolate user inputs; consume `.value` explicitly

---

## Required Cell Patterns

### 1. Setup Cell Pattern
Every Marimo notebook MUST begin with the following exact cell:

```python
@app.cell
def setup_pyoso():
    # This code sets up pyoso to be used as a database provider for this notebook
    # This code is autogenerated. Modification could lead to unexpected results :)
    import marimo as mo
    from pyoso import Client
    client = Client()
    try:
        pyoso_db_conn = client.dbapi_connection()    
    except Exception as e:
        pyoso_db_conn = None
    return mo, client, pyoso_db_conn
```

### 2. Documentation Cell Pattern
Each app must include an `about_app` cell that combines title, description, and details accordion in a single `mo.vstack()`:

```python
@app.cell
def about_app(mo):
    mo.vstack([
        mo.md("""
        # App Title
        <small>Author: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">OSO Team</span> Â· Last Updated: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">[Date]</span></small>
        """),
        mo.md("""
        Brief description of what this app does.
        Additional context or notes about the app.
        """),
        mo.accordion({
            "<b>Click to see details on how app was made</b>": mo.accordion({
                "Methodology": """
                - Explanation of how the app works
                - Key definitions and metrics
                - Data processing approach
                - Important caveats or limitations
                """,
                "Data Sources": """
                - Project registries (with links)
                - Event data sources (with links)
                - Spreadsheets / connectors / static files
                - Any other external data sources
                """,
                "Further Resources": """
                - [Getting Started with Pyoso](https://docs.opensource.observer/docs/get-started/python)
                - [Using the Semantic Layer](https://docs.opensource.observer/docs/get-started/using-semantic-layer)
                - [Marimo Documentation](https://docs.marimo.io/)
                """
            })
        })    
    ])
    return
```

---

## Common Reusable Building Blocks

### Import Libraries
```python
@app.cell
def import_libraries():
    # Standard library imports
    import datetime
    
    # Third-party imports
    import pandas as pd
    import plotly.express as px
    import plotly.graph_objects as go
    
    return datetime, pd, px, go
```

### Get Data
```python
@app.cell
def get_data(client, ...):
    _query = f"""
    SELECT
      column1,
      column2,
      column3
    FROM table_name
    WHERE condition = '{parameter.value}'
    """
    
    df_data = client.to_pandas(_query)
    return (df_data,)
```

### Configuration Settings
```python
@app.cell
def configuration_settings(mo, ...):
    parameter_input = mo.ui.dropdown(
        options=["option1", "option2"],
        value="option1",
        label="Parameter"
    )
    
    mo.vstack([
        mo.md("### Configuration"),
        parameter_input
    ])
    return (parameter_input,)
```

### Generate Stats
```python
@app.cell
def generate_stats(mo, df_data, ...):
    total_count = mo.stat(
        label="Total Count",
        bordered=True,
        value=f"{len(df_data):,.0f}",
    )
    
    mo.hstack([total_count], widths="equal", gap=1)
    return
```

### Generate Table
```python
@app.cell
def generate_table(mo, df_data):
    mo.ui.table(
        df_data.reset_index(drop=True),
        selection=None,
        show_column_summaries=False,
        show_data_types=False,
        page_size=50
    )
    return
```

### Generate Plot
```python
@app.cell
def generate_plot(mo, df_data, px, ...):
    def make_fig(dataframe, title=""):
        fig = px.scatter(
            dataframe,
            x="x_column",
            y="y_column",
            title=f"<b>{title}</b>"
        )
        fig.update_layout(
            paper_bgcolor="white",
            plot_bgcolor="white",
            font=dict(size=12, color="#111"),
            title=dict(text=title, x=0, xanchor="left"),
            margin=dict(t=50, l=20, r=20, b=20),
            legend_title="",
            hovermode="x"
        )
        fig.update_xaxes(showgrid=False, linecolor="#000", ticks="outside")
        fig.update_yaxes(showgrid=True, gridcolor="#DDD", linecolor="#000", ticks="outside")
        return fig

    _fig = make_fig(df_data, "Chart Title")
    mo.ui.plotly(_fig)
    return
```

---

## Cell Naming Conventions

### Required Named Cells:
- `setup_pyoso()` - Database setup (exact pattern required)
- `about_app(mo)` - Documentation with vstack pattern

### Common Building Block Cells (use as needed):
- `import_libraries()` - All imports organized by type
- `get_data(...)` - Data fetching and processing
- `configuration_settings(mo, ...)` - UI controls and settings
- `generate_stats(mo, ...)` - Key metrics and statistics
- `generate_table(mo, ...)` - Tabular data display
- `generate_plot(mo, ...)` - Primary visualizations
- `filter_data(...)` - Data filtering and transformation
- `create_*_inputs(mo, ...)` - Specific UI element creation
- `show_*_info(mo, ...)` - Information display cells

### Helper Cells (use `_()` pattern):
- Utility functions and calculations
- State initialization
- Simple data transformations
- Helper computations

---

## Cell Organization Order

1. `setup_pyoso()` - Always first (REQUIRED)
2. `about_app(mo)` - Documentation (REQUIRED)
3. `import_libraries()` - All imports (if needed)
4. `configuration_settings(mo, ...)` - UI controls (if needed)
5. `get_data(...)` - Data fetching (if needed)
6. `filter_data(...)` - Data processing (if needed)
7. `generate_stats(mo, ...)` - Key metrics (if needed)
8. `generate_table(mo, ...)` - Data tables (if needed)
9. `generate_plot(mo, ...)` - Visualizations (if needed)
10. Helper cells with `_()` pattern as needed

---

## UI Components
- Use `mo.ui.*` for dropdowns, multiselects, sliders, checkboxes, and buttons
- Widget variables end with `_input`; consume `.value` downstream
- Organize with `mo.hstack()` and `mo.vstack()`
- For simple inputs, show directly; for grouped controls, wrap in `mo.vstack()`

```python
# Simple widget
project_input = mo.ui.dropdown(...)
project_input
return (project_input,)

# With header
mo.vstack([
    mo.md("### Configuration"),
    project_input
])
return (project_input,)
```

- Gate expensive operations with a button:  
  ```python
  run_analysis_input = mo.ui.run_button()
  run_analysis_input
  ```
- And then use it to gate expensive operations:
  ```python
  mo.stop(not run_analysis_input.value)
  # Your expensive operation here
  ```

---

## Cell Dependencies and Return Patterns
- Always `return` variables that will be used in other cells
- Use `return (var,)` for single and `return (var1, var2)` for multiple
- Do **not** use `_` prefix for returned variables (they must be usable by other cells)
- UI cells must always return widget variables

```python
# Data processing
@app.cell
def get_data(client, project_input):
    _query = f"SELECT * FROM table WHERE id = '{project_input.value}'"
    df_data = client.to_pandas(_query)
    return (df_data,)

# UI cell
@app.cell
def configuration_settings(mo):
    project_input = mo.ui.dropdown(...)
    mo.vstack([project_input])
    return (project_input,)
```

---

## State Management
- Avoid `mo.state` unless persistence or synchronization is truly required
- Prefer explicit value-driven reactivity

---

## Visualization Standards
- Use Plotly as the default charting library
- Always sort by x-axis before plotting
- Apply a shared styling helper:

```python
def make_fig(dataframe, title=""):
    fig = px.line(
        dataframe,
        x="sample_date",
        y=dataframe.columns[1:],
        title=f"<b>{title}</b>"
    )
    fig.update_layout(
        paper_bgcolor="white",
        plot_bgcolor="white",
        font=dict(size=12, color="#111"),
        title=dict(text=title, x=0, xanchor="left"),
        margin=dict(t=50, l=20, r=20, b=20),
        legend_title="",
        hovermode="x"
    )
    fig.update_xaxes(showgrid=False, linecolor="#000", ticks="outside")
    fig.update_yaxes(showgrid=True, gridcolor="#DDD", linecolor="#000", ticks="outside")
    return fig

_fig = make_fig(_df, "Title")
mo.ui.plotly(_fig)
```

- Use consistent color palettes
- Titles left-aligned; legends concise
- Avoid secondary y-axes
- Format hover templates for readability

---

### Data Tables
- Use `mo.ui.table()` for interactive display
- Include `format_mapping` for numbers/dates
- Set `page_size` appropriately (default 50)
- Disable unused features: `show_data_types=False`, `show_column_summaries=False`
- Clean column names and sort before display
- Wrap in `mo.vstack()` with section headers

---

## Data Processing
- Use pandas method chaining and descriptive names
- Handle dates with `pd.to_datetime()`
- Keep transformations in dedicated cells
- Variables:
  - DataFrames across cells: normal names (`df_projects`)
  - Local variables inside cells: `_` prefix (`_query`, `_result`)
  - Widgets: `_input` suffix (`project_name_input`)
- **Never** use `_` prefix for variables that must be returned between cells

---

## SQL Queries (Trino)
- Dialect: **Trino**
- Indent: **2 spaces**
- One variable per line in `SELECT` and CTEs
- No padding mid-line
- No trailing semicolons
- Use CTEs for readability
- Comment complex logic
- Write queries in one of two approved patterns:

```python
# Option 1: mo.sql
_query = f"""
  SELECT
    created_at,
    updated_at,
    artifact_id
  FROM repositories_v0
"""
_df = mo.sql(
    _query,
    engine=pyoso_db_conn
)

# Option 2: client.to_pandas
_query = f"""
  SELECT
    created_at,
    updated_at,
    artifact_id
  FROM repositories_v0
"""
_df = client.to_pandas(_query)
```

---

## Error Handling and Robustness
- Keep error handling simple and minimal
- Prefer clean, direct flows over defensive programming
- Surface concise error messages with `mo.md()`
- **CRITICAL: Never use premature return statements** - Marimo cells must execute completely. If data is empty, let the UI components handle it naturally (empty tables, empty plots, etc.)

---

## Performance
- Fetch only necessary data ranges
- Cache expensive computations in separate cells
- Use efficient pandas operations
- Avoid rendering very large tables; paginate or sample instead

---

## Code Style
- Python: 4 spaces (PEP 8)
- SQL: 2 spaces
- Descriptive names: `*_input` (widgets), `fig_*` (plots), `_var` (locals)
- Global constants: `UPPER_CASE`
- Functions: focused, typed, and reusable
- Consistent formatting across cells

---

## Documentation
- Markdown for context; concise and data-driven
- Inline comments for complex logic

---

## Workflow
1. Define objective
2. Setup â documentation (REQUIRED)
3. Data connections (if needed)
4. Fetch and validate data (if needed)
5. Create UI components (if needed)
6. Build visualizations (if needed)
7. Add markdown + accordion documentation
8. Test interactivity and error handling

---

## ð¨ CRITICAL ANTI-PATTERNS - NEVER ALLOWED ð¨

### â PREMATURE RETURNS - ABSOLUTELY FORBIDDEN
**NEVER use conditional return statements in marimo cells. This breaks the reactive system.**

```python
# â WRONG - NEVER DO THIS
@app.cell
def generate_stats(mo, df_data):
    if len(df_data) == 0:
        mo.md("No data available")
        return  # â THIS BREAKS MARIMO!
    
    # rest of code...

# â CORRECT - Always execute to completion
@app.cell
def generate_stats(mo, df_data):
    total_count = mo.stat(
        label="Total Count",
        value=f"{len(df_data):,.0f}" if len(df_data) > 0 else "0",
    )
    mo.hstack([total_count])
    return
```

### â CONDITIONAL UI RENDERING - FORBIDDEN
**NEVER use conditional rendering with early returns. Let UI components handle empty states.**

```python
# â WRONG - NEVER DO THIS
@app.cell
def generate_table(mo, df_data):
    if len(df_data) == 0:
        mo.md("No data")
        return  # â BREAKS MARIMO!
    
    mo.ui.table(df_data)

# â CORRECT - Let empty table display naturally
@app.cell
def generate_table(mo, df_data):
    mo.ui.table(df_data)  # Empty table is fine
    return
```

### â CONDITIONAL PLOT RENDERING - FORBIDDEN
**NEVER use conditional plot rendering with early returns. Create proper empty figures.**

```python
# â WRONG - NEVER DO THIS
@app.cell
def generate_plot(mo, df_data, px):
    if len(df_data) == 0:
        mo.md("No data")
        return  # â BREAKS MARIMO!
    
    fig = px.scatter(df_data, ...)
    mo.ui.plotly(fig)

# â CORRECT - Create empty figure with proper styling
@app.cell
def generate_plot(mo, df_data, px, go):
    def make_fig(dataframe, title=""):
        if len(dataframe) == 0:
            fig = go.Figure()
            fig.update_layout(
                title=title,
                annotations=[dict(
                    x=0.5, y=0.5,
                    xref="paper", yref="paper",
                    text="No data available",
                    showarrow=False
                )]
            )
            return fig
        
        fig = px.scatter(dataframe, ...)
        return fig
    
    _fig = make_fig(df_data, "Chart Title")
    mo.ui.plotly(_fig)
    return
```

## Other Anti-Patterns
- Hardcoding values that should be configurable
- Mixing data processing and visualization in the same cell
- Using widget objects directly in expressions (instead of `.value`)
- Returning `_`-prefixed variables (breaks dependencies)
- Overly complex single cells
- Inconsistent styling across visualizations
- Over-engineering error handling
- Using `_()` pattern for main building blocks (use named cells instead)