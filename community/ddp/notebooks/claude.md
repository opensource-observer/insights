# DDP Notebooks Style Guide

This file documents the conventions and patterns for creating and editing marimo notebooks in the Developer Data Portal (DDP).

## Notebook Structure

DDP data model notebooks follow this structure (top to bottom):

### Content cells (rendered order)
1. **Title** - `# Model Name` + one-line intro + Preview SQL snippet
2. **Overview section** - What the model is and why it matters
3. **Data source comparison / key concepts** - Model-specific context (hierarchy, ID systems, etc.)
4. **Data lineage** - Mermaid diagram showing transformation flow
5. **Key fields** (if applicable) - Detailed field documentation
6. **Model previews** - Accordion previews with SQL snippets and row counts
7. **Best Practices** - Table with Goal / Recommended Approach / Why columns
8. **Live data exploration** - Header + executed queries with stat widgets and charts
9. **Sample queries** - Markdown + executed pairs (SQL in markdown, then executed in next cell)
10. **Methodology / Edge cases** (if applicable)
11. **Related models** - Links to sibling notebooks

### Infrastructure cells (bottom of file)
12. **Helper utilities cell** - `render_table_preview` and supporting functions
13. **Imports cell** - `plotly.express` (and `pandas` if needed)
14. **Setup cell** (`setup_pyoso`) - Initialize pyoso client and database connection

Infrastructure cells are placed at the bottom of the file because marimo resolves dependencies automatically — cell order in the file doesn't affect execution order.

## Sidebar Ordering

Models are ordered by conceptual dependency (entities → activity → analysis):

1. Ecosystems
2. Repositories
3. Developers
4. Commits
5. Events
6. Timeseries Metrics

## Required Cells

### Setup Cell
```python
@app.cell(hide_code=True)
def setup_pyoso():
    # This code sets up pyoso to be used as a database provider for this notebook
    # This code is autogenerated. Modification could lead to unexpected results :)
    import pyoso
    import marimo as mo
    pyoso_db_conn = pyoso.Client().dbapi_connection()
    return mo, pyoso_db_conn
```

### Helper Utilities Cell
```python
@app.cell(hide_code=True)
def _(mo, pyoso_db_conn):
    def get_model_preview(model_name, limit=5):
        return mo.sql(f"SELECT * FROM {model_name} LIMIT {limit}",
                      engine=pyoso_db_conn, output=False)

    def get_row_count(model_name):
        result = mo.sql(f"SHOW STATS FOR {model_name}",
                        engine=pyoso_db_conn, output=False)
        return result['row_count'].sum()

    def generate_sql_snippet(model_name, df_results, limit=5):
        column_names = df_results.columns.tolist()
        columns_formatted = ',\n  '.join(column_names)
        sql_snippet = f"""```sql
SELECT
  {columns_formatted}
FROM {model_name}
LIMIT {limit}
```
"""
        return mo.md(sql_snippet)

    def render_table_preview(model_name):
        df = get_model_preview(model_name)
        if df.empty:
            return mo.md(f"**{model_name}**\n\nUnable to retrieve preview (table might be empty or inaccessible).")
        sql_snippet = generate_sql_snippet(model_name, df, limit=5)
        fmt = {c: '{:.0f}' for c in df.columns if df[c].dtype == 'int64' and ('_id' in c or c == 'id')}
        table = mo.ui.table(df, format_mapping=fmt, show_column_summaries=False, show_data_types=False)
        row_count = get_row_count(model_name)
        col_count = len(df.columns)
        title = f"{model_name} | {row_count:,.0f} rows, {col_count} cols"
        return mo.accordion({title: mo.vstack([sql_snippet, table])})

    return (render_table_preview,)
```

## Cell Conventions

- **All cells** must have `hide_code=True` — no exceptions for content or infrastructure cells
- Use `"""` for markdown strings, **not** `r"""` (raw strings)
- Use `mo.md()` for markdown, `mo.mermaid()` for data lineage diagrams
- Prefix throwaway variables with `_` to avoid marimo "multiple definitions" errors
- Named data used by downstream cells (e.g., chart data) should use descriptive names like `df_top_ecosystems`

## Visualization Patterns

### Import Plotly
```python
@app.cell(hide_code=True)
def imports():
    import plotly.express as px
    return (px,)
```

Add `pandas` to the same cell if needed for `pd.to_datetime()`:
```python
@app.cell(hide_code=True)
def imports():
    import pandas as pd
    import plotly.express as px
    return (pd, px)
```

### Chart Styling
Use consistent plotly styling:
```python
_fig.update_layout(
    template='plotly_white',
    margin=dict(t=20, l=0, r=0, b=0),
    height=400,
    hovermode='x unified'
)
_fig.update_xaxes(
    title='',
    showgrid=False,
    linecolor="#000",
    linewidth=1
)
_fig.update_yaxes(
    title='Your Y-Axis Label',
    showgrid=True,
    gridcolor="#E5E5E5",
    linecolor="#000",
    linewidth=1
)
```

For horizontal bar charts, add:
```python
yaxis=dict(categoryorder='total ascending')
```

For line/area charts with dates, add:
```python
xaxis=dict(tickformat="%b %Y")  # or "%b %d" for shorter ranges
```

For multi-series charts with legends:
```python
legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1, title_text='')
```

### Color Palette
- Primary: `#4C78A8` (blue) — default for single-series charts
- Secondary: `#F58518` (orange) — second series or secondary charts
- Tertiary: `#72B7B2` (teal) — third series
- Area fill: use 0.2 opacity variant (e.g., `rgba(76, 120, 168, 0.2)`)

## Stats Widgets

Use bordered stats with captions:
```python
mo.hstack([
    mo.stat(label="Label 1", value=f"{value1:,}", bordered=True, caption="Context info"),
    mo.stat(label="Label 2", value=f"{value2:,}", bordered=True, caption="Context info"),
], widths="equal", gap=1)
```

**Rules:**
- Always use `bordered=True`
- Always include a `caption` for context
- Use `widths="equal"` and `gap=1` for consistent spacing
- Place stats **above** charts using `mo.vstack([stats_row, chart])`
- Typically 3-4 stats per row

## Data Lineage

Use `mo.mermaid()` for data lineage diagrams (not ASCII art):
```python
@app.cell(hide_code=True)
def _(mo):
    mo.mermaid("""
    graph TD
        A[source_model<br/>Description] --> B[intermediate_model<br/>Description]
        B --> C[final_model<br/>Description]
    """)
    return
```

## Sample Queries

Present as **markdown + executed pairs** — each query has two cells:

1. **Markdown cell**: Description + SQL in a code block
2. **Executed cell**: Same SQL run via `mo.sql()`

Both cells should have `hide_code=True`.

```python
@app.cell(hide_code=True)
def _(mo):
    mo.md("""
    ### 1. Query Title

    Description of what the query does.

    ```sql
    SELECT column1, column2
    FROM oso.model_name
    WHERE condition
    LIMIT 10
    ```
    """)
    return


@app.cell(hide_code=True)
def _(mo, pyoso_db_conn):
    _df = mo.sql(
        f"""
        SELECT column1, column2
        FROM oso.model_name
        WHERE condition
        LIMIT 10
        """,
        engine=pyoso_db_conn
    )
    return
```

## Live Data Queries

When executing queries for visualizations:
- **Always use narrow date ranges** (7-30 days) to keep execution fast
- Use `CURRENT_DATE - INTERVAL 'N' DAY` pattern
- Convert dates with `pd.to_datetime()` for plotly

## Markdown Conventions

- Use regular markdown headings, **not** `mo.callout()` for important info
- Use `"""` strings, not `r"""` raw strings
- Best Practices tables follow this format:

```markdown
| Goal | Recommended Approach | Why? |
|:------|:---------------------|:------|
| **Goal description** | Model or approach | Explanation |
```

### Related Models Links
Use relative markdown links to other notebooks:
```python
mo.md("""
## Related Models

- **Ecosystems**: [ecosystems.py](./ecosystems.py) — Ecosystem definitions and hierarchy
- **Repositories**: [repositories.py](./repositories.py) — Repository bridge model
- **Developers**: [developers.py](./developers.py) — Unified developer identities
- **Commits**: [commits.py](./commits.py) — Unified commit data
- **Events**: [events.py](./events.py) — GitHub Archive event data
- **Timeseries Metrics**: [timeseries-metrics.py](./timeseries-metrics.py) — Aggregated time series
""")
```

## Data Sources Reference

### Ecosystem Models (Open Dev Data)
- `oso.stg_opendevdata__ecosystems` — Ecosystem definitions (name, is_crypto, is_chain, is_category)
- `oso.stg_opendevdata__ecosystems_child_ecosystems` — Parent-child hierarchy links
- `oso.stg_opendevdata__ecosystems_repos` — Direct repo-to-ecosystem mapping
- `oso.stg_opendevdata__ecosystems_repos_recursive` — Recursive repo mapping with distance + path

### Repository Bridge Model
- `oso.int_opendevdata__repositories_with_repo_id` — Maps ODD repos to GitHub integer IDs (the canonical bridge)

### Developer Models
- `oso.int_ddp__developers` — Unified developer list (ODD + GHA, keyed by `user_id`)
- `oso.stg_opendevdata__developers` — ODD developers with GraphQL IDs

### Commit Models
- `oso.int_ddp__commits_unified` — Combined ODD + GHA commits (not deduped)
- `oso.int_ddp__commits_deduped` — Deduplicated unified commits
- `oso.stg_opendevdata__commits` — Raw ODD commits with identity resolution

### GitHub Archive Models (broader event coverage)
- `oso.stg_github__events` — Raw events with nested fields
- `oso.int_gharchive__github_events` — Standardized events (canonical entrypoint)
- `oso.int_ddp_github_events` — Curated subset of event types
- `oso.int_ddp_github_events_daily` — Daily aggregation with normalized types
- `oso.int_gharchive__developer_activities` — Daily rollup for MAD metrics

### Timeseries Models
- `oso.stg_opendevdata__repo_developer_28d_activities` — 28-day rolling activity (day × repo × developer)
- `oso.stg_opendevdata__eco_mads` — Pre-calculated ecosystem MAD counts (day × ecosystem)

### ID Mapping
- `oso.int_github__node_id_map` — Decode GitHub GraphQL Node IDs to REST integer IDs

### DDP Curated Event Types
The DDP curated models include these event types:
- `PushEvent` — Commits pushed
- `PullRequestEvent` — PR activity
- `PullRequestReviewEvent` — Code reviews
- `PullRequestReviewCommentEvent` — Review comments
- `IssuesEvent` — Issue activity
- `WatchEvent` — Stars
- `ForkEvent` — Forks

## Key Expectations to Document

When writing model documentation, explicitly state:

1. **Data Freshness**: GitHub Archive can be ~3 days behind real-time
2. **Completeness**: Only public GitHub timeline; no private repos or deleted events
3. **Identity**: Distinguish between `actor_id` (GitHub) and `canonical_developer_id` (Open Dev Data)
4. **Join Keys**: Document which IDs to use for joins (e.g., `repo_id` for cross-source joins)

## File Naming

- Model notebooks: `data/models/{model_name}.py`
- Metric definitions: `data/metric-definitions/{metric_name}.py`
- Source documentation: `data/sources/{source_name}.py`
- Insights/dashboards: `insights/{insight_name}.py`
