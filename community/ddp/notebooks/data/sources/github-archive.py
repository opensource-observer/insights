import marimo

__generated_with = "0.18.4"
app = marimo.App(width="full")


@app.cell
def setup_pyoso():
    # This code sets up pyoso to be used as a database provider for this notebook
    # This code is autogenerated. Modification could lead to unexpected results :)
    import pyoso
    import marimo as mo
    pyoso_db_conn = pyoso.Client().dbapi_connection()
    return mo, pyoso_db_conn


@app.cell(hide_code=True)
def _(mo, pyoso_db_conn):
    def get_model_preview(model_name, limit=5):
        return mo.sql(f"SELECT * FROM {model_name} LIMIT {limit}", 
                      engine=pyoso_db_conn, output=False)

    def get_row_count(model_name):
        result = mo.sql(f"SHOW STATS FOR {model_name}", 
                        engine=pyoso_db_conn, output=False)
        return result['row_count'].sum()    

    def generate_sql_snippet(model_name, df_results, limit=5):
        column_names = df_results.columns.tolist()
        # Format columns with one per line, indented
        columns_formatted = ',\n  '.join(column_names)
        sql_snippet = f"""```sql
SELECT 
  {columns_formatted}
FROM {model_name}
LIMIT {limit}
```
"""
        return mo.md(sql_snippet)

    def render_table_preview(model_name):
        df = get_model_preview(model_name)
        sql_snippet = generate_sql_snippet(model_name, df, limit=5)
        fmt = {c: '{:.0f}' for c in df.columns if df[c].dtype == 'int64' and ('_id' in c or c == 'id')}
        table = mo.ui.table(df, format_mapping=fmt, show_column_summaries=False, show_data_types=False)
        row_count = get_row_count(model_name)
        col_count = len(df.columns)
        title = f"{model_name} | {row_count:,.0f} rows, {col_count} cols"
        return mo.accordion({title: mo.vstack([sql_snippet, table])})
    return (render_table_preview,)


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        """
        # GitHub Archive

        **Maintained by:** [gharchive.org](https://gharchive.org)

        ## Overview

        GitHub Archive records the public GitHub timeline, archiving all public GitHub activity including pushes, pull requests, 
        issues, comments, and many other event types. The dataset provides complete coverage of public GitHub activity and is 
        continuously updated. Events use GitHub's **REST API IDs** rather than GraphQL node IDs, allowing direct joins with OSS Directory 
        repositories via the `id` field, but requiring OSS Directory as an intermediary to join with Open Dev Data.

        ## Primary Tables

        ### Events

        Contains all public GitHub activity events. The `type` field indicates the event category (push, pull request, issue, etc.), 
        with detailed information in the JSON `payload` field. Repository and actor IDs are extracted from the payload and use 
        GitHub's REST API ID system (`repo.id` and `actor.id`). These REST API IDs can be directly joined with OSS Directory 
        repositories using the `id` field.
        """
    )
    return


@app.cell(hide_code=True)
def _(render_table_preview):
    render_table_preview("stg_github__events")
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        """
        ## Limitations

        The dataset does not capture contributions made when repositories were private (only public activity is recorded). There may 
        be gaps in coverage if the GitHub API is down or the indexer experiences issues, potentially missing hours or days of activity. 
        While comprehensive, the dataset is not 100% complete due to these edge cases.
        """
    )
    return


if __name__ == "__main__":
    app.run()
