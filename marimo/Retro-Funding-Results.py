import marimo

__generated_with = "unknown"
app = marimo.App()


@app.cell
def setup_pyoso():
    # This code sets up pyoso to be used as a database provider for this notebook
    # This code is autogenerated. Modification could lead to unexpected results :)
    import pyoso
    import marimo as mo
    client = pyoso.Client()
    pyoso_db_conn = client.dbapi_connection()
    return (mo,)


@app.cell
def about_app(mo):
    mo.md(r"""# **Retro Funding S7/S8**""")
    return


@app.cell
def _(pd, requests):
    #https://raw.githubusercontent.com/ethereum-optimism/Retro-Funding/refs/heads/main/results/S8/M7/outputs/onchain__results.json

    MOST_RECENT_SNAPSHOT = "M7"
    SNAPSHOT_NUM = int(MOST_RECENT_SNAPSHOT[1:])
    SNAPSHOTS = {f"M{i}": ("S7" if i <= 6 else "S8") for i in range(1, SNAPSHOT_NUM+1)}
    BASE_URL = "https://raw.githubusercontent.com/ethereum-optimism/Retro-Funding/refs/heads/main/results"


    def get_snapshot_data(period, results_type):
        season = SNAPSHOTS[period]
        url = f"{BASE_URL}/{season}/{period}/outputs/{results_type}__results.json"
        response = requests.get(url)
        data = response.json()
        return data

    def get_onchain_metrics_data(period, latest_only=True):
        season = SNAPSHOTS[period]
        url = f"{BASE_URL}/{season}/{period}/data/onchain__metrics_by_project.csv"
        df = pd.read_csv(url)
        if latest_only:
            latest_date = df['sample_date'].max()
            df = df[df['sample_date'] == latest_date]
        return df    
    return SNAPSHOTS, SNAPSHOT_NUM, get_onchain_metrics_data, get_snapshot_data


@app.cell
def configuration_settings(
    SNAPSHOTS,
    SNAPSHOT_NUM,
    get_onchain_results_by_snapshot,
    mo,
    pd,
):
    get_period, set_period = mo.state(SNAPSHOT_NUM)

    def make_button(tag: str):
        mnum = tag[1:]
        return mo.ui.button(
            label=tag,
            on_click=lambda v, mnum=mnum: (set_period(mnum), v)[1]
        )

    ordered_buttons = []
    _all_onchain_rewards_snapshots = []
    _prev_season = None
    for i in range(SNAPSHOT_NUM, 1 - 1, -1):
        _period_name = f"M{i}"
        _button = make_button(_period_name)
        _this_season = SNAPSHOTS[_period_name]
        _onchain_rewards = get_onchain_results_by_snapshot(i)
        _onchain_rewards['snapshot'] = _period_name
        _all_onchain_rewards_snapshots.append(_onchain_rewards)
        if _this_season != _prev_season:
            _prev_season = _this_season
            ordered_buttons.append(mo.md(f"**{_this_season}**"))
        ordered_buttons.append(_button)    

    df_all_onchain_rewards = pd.concat(_all_onchain_rewards_snapshots, axis=0)    
    return df_all_onchain_rewards, get_period, ordered_buttons


@app.cell
def project_metrics_section_header(mo, ordered_buttons):
    mo.vstack([
        mo.hstack([
            mo.vstack([
                mo.md("## Results by Measurement Period"),
                mo.md("*Each measurement period represents a monthly rewards snapshot (M1 = February, M7 = August).*")
            ]),
            mo.vstack([
                mo.hstack(
                    [mo.md("**Measurement Period**")],
                    justify="end",
                ),
                mo.hstack(
                    ordered_buttons,
                    justify="end", 
                    gap=0.5
                ),
            ])    
        ]),
        mo.md("---")
    ])
    return


@app.cell
def _():
    #all_rewards = [pd.concat(get_onchain_results_by_snapshot(p) for p in range(1,)]
    return


@app.cell
def _(
    atlas_url,
    df_all_onchain_rewards,
    get_onchain_metrics_data,
    get_period,
    pd,
):
    this_period = get_period()
    this_snapshot = f"M{this_period}"

    #df_rewards = get_onchain_results_by_snapshot(this_period)
    df_rewards = df_all_onchain_rewards[df_all_onchain_rewards['snapshot'] == this_snapshot]
    df_metrics = get_onchain_metrics_data(this_snapshot)

    _em = pd.json_normalize(df_rewards["eligibility_metrics"])
    _em.index = df_rewards["Atlas ID"]
    _em.columns = [c.replace('_',' ').title() for c in _em.columns]
    df_eligibility = (
        df_rewards
        .drop(columns=['eligibility_metrics', 'Project ID'])
        .set_index('Atlas ID')
        .join(_em)
    )
    df_eligibility['Link'] = df_eligibility.index.map(atlas_url)

    return df_eligibility, df_metrics, df_rewards, this_period, this_snapshot


@app.cell
def _():
    return


@app.cell
def chain_filter_configuration(df_metrics, df_rewards, mo, this_snapshot):
    available_chains = sorted(df_metrics['chain'].unique().tolist())

    chain_filter = mo.ui.multiselect(
        options=available_chains,
        value=available_chains,
        label="**Filter by Chain**",
        full_width=True
    )

    mo.vstack([
        mo.hstack([
            mo.vstack([        
                mo.md(f"### :sparkles: {this_snapshot} Results"),
                mo.md(f"A total of **{df_rewards['OP Reward'].sum():,.0f} OP** was distributed to **{len(df_rewards[df_rewards['OP Reward']>0])} onchain builders**.")
            ]),
            mo.vstack([
                mo.hstack([chain_filter], justify='end')
            ])
        ])
    ])
    return (chain_filter,)


@app.cell
def _(show_project_metrics_data):
    show_project_metrics_data()
    return


@app.cell
def show_project_metrics_data(chain_filter, df_metrics, df_rewards, mo):
    def show_project_metrics_data():

        # Filter metrics by selected chains
        _filtered_metrics = df_metrics[df_metrics['chain'].isin(chain_filter.value)]

        # Pivot to get current vs previous month data
        _metrics_pivot = _filtered_metrics.pivot_table(
            index=['project_id', 'display_name'],
            columns=['metric_name', 'measurement_period'],
            values='amount',
            aggfunc='sum',
            fill_value=0
        ).reset_index()


        _formatted_columns = ['Project ID', 'Project Name']
        for metric, period in _metrics_pivot.columns[2:]:
            _formatted_name = f"{metric.replace('_', ' ').title()} ({period})"
            _formatted_columns.append(_formatted_name)

        _metrics_pivot.columns = _formatted_columns

        _metrics_pivot = _metrics_pivot.merge(df_rewards[['Project ID', 'OP Reward']], on='Project ID')
        _metrics_pivot = _metrics_pivot.drop(columns='Project ID')
        _numeric_cols = [col for col in _metrics_pivot.columns if col not in ['Project ID', 'Project Name']]

        _metrics_pivot.sort_values(by=['OP Reward', 'Project Name'], ascending=False, inplace=True)

        def _fmt(col):
            col = col.lower()
            if 'tvl' in col:
                return '${:,.0f}' 
            elif 'gas' in col:
                return '{:,.2f}' 
            else:
                return '{:,.0f}'

        _format_mapping = {
            col: _fmt(col)
            for col in _numeric_cols
        }

        _table = mo.ui.table(
            _metrics_pivot.reset_index(drop=True),
            selection=None,
            show_column_summaries=False,
            show_data_types=False,
            page_size=25,
            format_mapping=_format_mapping,
            freeze_columns_left=['Project Name', 'OP Reward']
        )
        return _table
    return (show_project_metrics_data,)


@app.cell
def project_eligibility_table(
    df_eligibility,
    mo,
    show_project_eligibility_stats,
    show_project_eligibility_table,
    this_period,
):
    mo.vstack([
        mo.md("---"),
        mo.md(f"### ðŸ”´ M{this_period} Eligibility"),
        show_project_eligibility_stats(df_eligibility),    
        show_project_eligibility_table(df_eligibility)    
    ])
    return


@app.cell
def show_project_eligibility_table(mo):
    def show_project_eligibility_table(df):

        _table_data = df.copy()
        _table_data['Is Eligible?'] = _table_data['Is Eligible?'].map({True: 'Yes', False: 'No'})
        _table = mo.vstack([
            mo.ui.table(
                _table_data.reset_index(drop=True),
                selection=None,
                show_column_summaries=False,
                show_data_types=False,
                page_size=25,
                format_mapping={
                    'OP Reward': '{:,.0f}',
                    'Transaction Count': '{:,.0f}',
                    'Active Days': '{:,.0f}',
                    'Gas Fees': '{:,.2f}'
                }
            )
        ])

        return _table
    return (show_project_eligibility_table,)


@app.cell
def show_project_eligibility_stats(mo):
    def show_project_eligibility_stats(df_eligibility):

        total_projects = mo.stat(
            label="Total Projects",
            bordered=True,
            value=f"{len(df_eligibility):,.0f}",
        )

        eligible_projects = mo.stat(
            label="Eligible Projects",
            bordered=True,
            value=f"{df_eligibility['Is Eligible?'].sum():,.0f}",
        )

        transaction_threshold = 1000
        active_days_threshold = 10

        below_transaction_min = mo.stat(
            label="Below Transaction Min",
            bordered=True,
            value=f"{(df_eligibility['Transaction Count'] < transaction_threshold).sum():,.0f}",
        )

        below_active_days_min = mo.stat(
            label="Below Active Day Min",
            bordered=True,
            value=f"{(df_eligibility['Active Days'] < active_days_threshold).sum():,.0f}",
        )

        stats = mo.hstack([
            total_projects,
            eligible_projects,
            below_transaction_min,
            below_active_days_min
        ], widths="equal", gap=1)

        return stats
    return (show_project_eligibility_stats,)


@app.cell
def _(get_snapshot_data, pd):
    def get_onchain_results_by_snapshot(period):
        snapshot = f"M{period}"
        results = get_snapshot_data(snapshot, "onchain")
        df = (
            pd.DataFrame(results)
            .rename(columns={
                'oso_project_id': 'Project ID',
                'display_name': 'Project',
                'op_atlas_id': 'Atlas ID',
                'op_reward': 'OP Reward',
                'is_eligible': 'Is Eligible?',
            })
        )
        return df[['Project ID', 'Project', 'Atlas ID', 'OP Reward', 'Is Eligible?', 'eligibility_metrics']]
        
    return (get_onchain_results_by_snapshot,)


@app.cell
def _():
    atlas_url = lambda a: f"https://atlas.optimism.io/project/{a}"
    return (atlas_url,)


@app.cell
def import_libraries():
    import datetime
    from itertools import groupby
    import json
    import pandas as pd
    import requests
    import plotly.express as px
    return pd, requests


@app.cell
def _():
    return


if __name__ == "__main__":
    app.run()
