import marimo

__generated_with = "0.15.3"
app = marimo.App(width="full")


@app.cell
def setup_pyoso():
    # This code sets up pyoso to be used as a database provider for this notebook
    # This code is autogenerated. Modification could lead to unexpected results :)
    import marimo as mo
    from pyoso import Client
    client = Client()
    try:
        pyoso_db_conn = client.dbapi_connection()    
    except Exception as e:
        pyoso_db_conn = None
    return client, mo


@app.cell
def about_app(mo):
    mo.vstack([
        mo.md("""
        # Retro Funding S8: Onchain Builders
        <small>Author: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">OSO Team</span> Â· Last Updated: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">2025-09-21</span></small>
        """),
        mo.md("""
        An interactive dashboard for analyzing onchain builder activity and eligibility for Retrofunding S8.
        Track transaction counts, active days, and project metrics across different measurement periods.
        """),
        mo.accordion({
            "<b>Click to see details on how app was made</b>": mo.accordion({
            "Methodology": """
            - Projects are filtered by measurement period (M1-M7)
            - Eligibility based on transaction count and active days criteria
            - Flagged projects are excluded from eligibility calculations
            - Metrics tracked include transaction volume, active days, and chain-specific activity
            """,
            "Data Sources": """
            - [Superchain S8 Onchain Builder Eligibility](https://docs.opensource.observer/docs/get-started/python)
            - [Superchain S8 Onchain Metrics](https://docs.opensource.observer/docs/get-started/using-semantic-layer)
            - Project registries and collection data
            """,
            "Further Resources": """
            - [Getting Started with Pyoso](https://docs.opensource.observer/docs/get-started/python)
            - [Using the Semantic Layer](https://docs.opensource.observer/docs/get-started/using-semantic-layer)
            - [Marimo Documentation](https://docs.marimo.io/)
            """
        })
        })    
    ])
    return


@app.cell
def _():
    LATEST_PERIOD = 7
    FLAG_LIST = [
        '0xaa1b878800206da24ee7297fb202ef98a6af0fb3ec298a65ba6b675cb4f4144b', # Test Project
        '0x482720e73e91229b5f7d5e2d80a54eb8a722309c26dba03355359788b18f4373', # M4 RubyScore (manufactured activity)
        '0x03f730811b2a61aa1e8f7bdb6676e4027ed2b8f10bb731789a5d10e5ddc1352c', # M6 Onchain Heritage (manufactured activity)
        '0x076a2b1418a515ff8c5bb11beed5630cc6fe7f65fd8d42d4403c4364514f2a30', # M6 BAG Guild Dapp (manufactured activity)
    ]
    return FLAG_LIST, LATEST_PERIOD


@app.cell
def configuration_settings(LATEST_PERIOD, mo):
    get_period, set_period = mo.state(LATEST_PERIOD)

    period_buttons = {}
    for _period_num in range(1, LATEST_PERIOD + 1):
        def make_button(period_num):
            def handle_click(v):
                set_period(period_num)
                return v

            return mo.ui.button(
                label=f"M{period_num}",
                on_click=handle_click
            )

        period_buttons[_period_num] = make_button(_period_num)    
    return get_period, period_buttons


@app.cell
def _(get_period):
    THIS_PERIOD_NUM = get_period()
    SEASON = 'S7' if THIS_PERIOD_NUM < 7 else 'S8'
    THIS_PERIOD = f'M{THIS_PERIOD_NUM}'
    THIS_PERIOD_DATE = f'2025-{str(THIS_PERIOD_NUM+1).zfill(2)}-01' # M1 = Feb (2), M2 = Mar (3)
    LAST_PERIOD_DATE = f'2025-{str(THIS_PERIOD_NUM).zfill(2)}-01'   # The month before the current period
    END_DATE = f'2025-{str(THIS_PERIOD_NUM+2).zfill(2)}-01'         # The month after the current period
    START_DATE = '2024-11-01'                                       # Arbitrary start date for timeseries graphs
    return (
        END_DATE,
        LAST_PERIOD_DATE,
        SEASON,
        THIS_PERIOD,
        THIS_PERIOD_DATE,
        THIS_PERIOD_NUM,
    )


@app.cell
def project_metrics_section_header(LATEST_PERIOD, mo, period_buttons):
    mo.vstack([
        mo.hstack([
            mo.vstack([
                mo.md("## Results by Measurement Period"),
                mo.md("*Each measurement period represents a monthly rewards snapshot (M1 = February, M7 = August).*")
            ]),
            mo.vstack([
                mo.hstack(
                    [mo.md("**Measurement Period**")],
                    justify="end",
                ),
                mo.hstack(
                    [period_buttons[i] for i in range(1, LATEST_PERIOD + 1)],
                    justify="end", 
                    gap=0.5
                ),
            ])    
        ]),
        mo.md("---")
    ])
    return


@app.cell
def chain_filter_configuration(THIS_PERIOD, df_metrics, df_rewards, mo):
    available_chains = sorted(df_metrics['chain'].unique().tolist())

    chain_filter = mo.ui.multiselect(
        options=available_chains,
        value=available_chains,
        label="**Filter by Chain**",
        full_width=True
    )

    mo.vstack([
        mo.hstack([
            mo.vstack([        
                mo.md(f"### :sparkles: {THIS_PERIOD} Results"),
                mo.md(f"A total of **{df_rewards['OP Reward'].sum():,.0f} OP** was distributed to **{len(df_rewards[df_rewards['OP Reward']>0])} onchain builders**.")
            ]),
            mo.vstack([
                mo.hstack([chain_filter], justify='end')
            ])
        ])
    ])
    return (chain_filter,)


@app.cell
def show_project_metrics_data(chain_filter, df_metrics, df_rewards, mo):
    def show_project_metrics_data():

        # Filter metrics by selected chains
        _filtered_metrics = df_metrics[df_metrics['chain'].isin(chain_filter.value)]
    
        # Pivot to get current vs previous month data
        _metrics_pivot = _filtered_metrics.pivot_table(
            index=['project_id', 'display_name'],
            columns=['metric_name', 'measurement_period'],
            values='amount',
            aggfunc='sum',
            fill_value=0
        ).reset_index()
    
    
        _formatted_columns = ['Project ID', 'Project Name']
        for metric, period in _metrics_pivot.columns[2:]:
            _formatted_name = f"{metric.replace('_', ' ').title()} ({period})"
            _formatted_columns.append(_formatted_name)
    
        _metrics_pivot.columns = _formatted_columns
    
        _metrics_pivot = _metrics_pivot.merge(df_rewards, on='Project ID')
        _metrics_pivot = _metrics_pivot.drop(columns='Project ID')
        _numeric_cols = [col for col in _metrics_pivot.columns if col not in ['Project ID', 'Project Name']]
    
        _metrics_pivot.sort_values(by=['OP Reward', 'Project Name'], ascending=False, inplace=True)
    
        def _fmt(col):
            col = col.lower()
            if 'tvl' in col:
                return '${:,.0f}' 
            elif 'gas' in col:
                return '{:,.2f}' 
            else:
                return '{:,.0f}'
    
        _format_mapping = {
            col: _fmt(col)
            for col in _numeric_cols
        }
    
        _table = mo.ui.table(
            _metrics_pivot.reset_index(drop=True),
            selection=None,
            show_column_summaries=False,
            show_data_types=False,
            page_size=25,
            format_mapping=_format_mapping,
            freeze_columns_left=['Project Name', 'OP Reward']
        )
        return _table

    show_project_metrics_data()    
    return


@app.cell
def project_eligibility_table(
    THIS_PERIOD,
    mo,
    show_project_eligibility_stats,
    show_project_eligibility_table,
):
    mo.vstack([
        mo.md("---"),
        mo.md(f"### ðŸ”´ {THIS_PERIOD} Eligibility"),
        show_project_eligibility_stats(),    
        show_project_eligibility_table()    
    ])
    return


@app.cell
def show_project_eligibility_stats(df_projects, mo):
    def show_project_eligibility_stats():

        total_projects = mo.stat(
            label="Total Projects",
            bordered=True,
            value=f"{len(df_projects):,.0f}",
        )
    
        eligible_projects = mo.stat(
            label="Eligible Projects",
            bordered=True,
            value=f"{df_projects['is_eligible'].sum():,.0f}",
        )
    
        transaction_threshold = 1000
        active_days_threshold = 10
    
        below_transaction_min = mo.stat(
            label="Below Transaction Min",
            bordered=True,
            value=f"{(df_projects['transaction_count'] < transaction_threshold).sum():,.0f}",
        )
    
        below_active_days_min = mo.stat(
            label="Below Active Day Min",
            bordered=True,
            value=f"{(df_projects['active_days'] < active_days_threshold).sum():,.0f}",
        )
    
        stats = mo.hstack([
            total_projects,
            eligible_projects,
            below_transaction_min,
            below_active_days_min
        ], widths="equal", gap=1)

        return stats
    return (show_project_eligibility_stats,)


@app.cell
def show_project_eligibility_table(df_projects, mo):
    def show_project_eligibility_table():

        _table_data = df_projects.copy()
        _table_data['is_eligible'] = _table_data['is_eligible'].map({True: 'Yes', False: 'No'})
        _table_data = _table_data.drop(columns=['project_id'])
        _table_data = _table_data.rename(columns={
            'project_name': 'Atlas ID',
            'display_name': 'Project Name',
            'transaction_count': 'Transaction Count',
            'active_days': 'Active Days',
            'is_eligible': 'Eligible'
        })
    
        _table = mo.vstack([
            mo.ui.table(
                _table_data.reset_index(drop=True),
                selection=None,
                show_column_summaries=False,
                show_data_types=False,
                page_size=25,
                format_mapping={
                    'Transaction Count': '{:,.0f}',
                    'Active Days': '{:,.0f}'
                }
            )
        ])

        return _table
    return (show_project_eligibility_table,)


@app.cell
def get_project_rewards(SEASON, THIS_PERIOD, pd):
    df_rewards = pd.read_json(f"https://raw.githubusercontent.com/ethereum-optimism/Retro-Funding/refs/heads/main/results/{SEASON}/{THIS_PERIOD}/outputs/onchain__results.json")
    df_rewards.rename(columns={'oso_project_id': 'Project ID', 'op_reward': 'OP Reward'}, inplace=True)
    df_rewards = df_rewards[['Project ID', 'OP Reward']]
    return (df_rewards,)


@app.cell
def get_project_data(FLAG_LIST, THIS_PERIOD_DATE, THIS_PERIOD_NUM, client):
    project_query = f"""
        SELECT
            p.project_id,
            p.project_name,
            p.display_name,
            e.transaction_count,
            e.active_days,
            (e.meets_all_criteria AND NOT (p.project_name IN ({stringify(FLAG_LIST)}))) AS is_eligible
        FROM int_superchain_s8_onchain_builder_eligibility AS e
        JOIN projects_v1 AS p ON e.project_id = p.project_id
        JOIN projects_by_collection_v1 AS pbc ON p.project_id = pbc.project_id
        WHERE
            pbc.collection_name = '8-{THIS_PERIOD_NUM}'
            AND e.sample_date = DATE '{THIS_PERIOD_DATE}'
        ORDER BY e.transaction_count DESC
    """

    df_projects = client.to_pandas(project_query)
    return (df_projects,)


@app.cell
def get_project_metrics_data(
    END_DATE,
    LAST_PERIOD_DATE,
    THIS_PERIOD_NUM,
    client,
):
    metrics_query = f"""
        SELECT
            m.project_id,
            p.display_name,
            pbc.project_name,
            m.chain,
            m.metric_name,
            DATE_FORMAT(m.sample_date, '%Y-%m-%d') AS sample_date,
            DATE_FORMAT(m.sample_date, '%b %Y') AS measurement_period,
            m.amount
        FROM int_superchain_s8_onchain_metrics_by_project AS m
        JOIN projects_by_collection_v1 AS pbc ON m.project_id = pbc.project_id
        JOIN projects_v1 AS p ON pbc.project_id = p.project_id
        WHERE
            pbc.collection_name = '8-{THIS_PERIOD_NUM}'
            AND m.sample_date >= DATE '{LAST_PERIOD_DATE}'
            AND m.sample_date < DATE '{END_DATE}'
    """

    df_metrics = client.to_pandas(metrics_query)
    return (df_metrics,)


@app.cell
def import_libraries():
    import datetime
    import pandas as pd
    import plotly.express as px
    return (pd,)


@app.function
def stringify(flag_list):
    return "'" + "', '".join(flag_list) + "'"


if __name__ == "__main__":
    app.run()
