import marimo

__generated_with = "0.15.3"
app = marimo.App(width="full")


@app.cell
def setup_pyoso():
    # This code sets up pyoso to be used as a database provider for this notebook
    # This code is autogenerated. Modification could lead to unexpected results :)
    import marimo as mo
    from pyoso import Client
    client = Client()
    try:
        pyoso_db_conn = client.dbapi_connection()    
    except Exception as e:
        pyoso_db_conn = None
    return client, mo


@app.cell
def about_app(mo):
    mo.vstack([
        mo.md("""
        # VC Portfolio Analysis
        <small>Author: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">OSO Team</span> Â· Last Updated: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">2025-09-20</span></small>
        """),
        mo.md("""
        An interactive dashboard for analyzing a VC portfolio.
        This dashboard provides insights into portfolio companies, funding rounds, and investment performance.
        """),
        mo.accordion({
            "<b>Click to see details on how app was made</b>": mo.accordion({
            "Methodology": """
            - **Portfolio Analysis**: Analyzes VC portfolio companies with funding data from CoreSignal venture events
            - **Team Growth Classification**: Categorizes companies into 5 growth states based on developer activity:
              â€¢ ðŸš€ Fast Growing (50%+ growth in active developers)
              â€¢ ðŸ“ˆ Steady (-10% to +50% growth)
              â€¢ ðŸ“‰ Shrinking (-50% to -10% decline)
              â€¢ ðŸ’€ Potentially Dead (<-50% decline or <0.2 developers)
              â€¢ â“ No Data (insufficient developer tracking data)
            - **Time Series Analysis**: Tracks monthly active developers over time with funding event annotations
            - **Interactive Filtering**: Filter by investor, date range, and funding stages
            - **Multi-dimensional View**: Combines funding data, developer metrics, and OSO project tracking
            """,
            "Data Sources": """
            - [CoreSignal Venture Events](https://coresignal.com/) - VC funding and investment data
            - [OSO Database](https://docs.opensource.observer/) - Developer activity metrics and project tracking
            - GitHub activity data aggregated monthly for active developer counts
            - Company-to-project mapping for portfolio companies tracked in OSO
            """,
            "Further Resources": """
            - [Getting Started with Pyoso](https://docs.opensource.observer/docs/get-started/python)
            - [Using the Semantic Layer](https://docs.opensource.observer/docs/get-started/using-semantic-layer)
            - [Marimo Documentation](https://docs.marimo.io/)
            """
        })
        })    
    ])
    return


@app.cell
def get_data(client, pd):
    df_venture = client.to_pandas("""
    WITH events AS (
      SELECT * 
      FROM int_events__coresignal_venture
    ),
    projects AS (
      SELECT DISTINCT to_oso_project_id AS project_id
      FROM events
    ),
    yearly_devs AS (
      SELECT
        project_id,
        DATE_TRUNC(YEAR, sample_date) AS year,
        AVG(amount) AS avg_devs
      FROM timeseries_metrics_by_project_v0
      JOIN projects USING project_id
      JOIN metrics_v0 USING metric_id
      WHERE metric_name = 'GITHUB_active_developers_monthly'
      GROUP BY 1, 2
    ),
    project_metrics AS (
      SELECT
        yd.project_id,
        COALESCE(AVG(CASE WHEN yd.year = DATE_TRUNC(YEAR, CURRENT_DATE()) THEN yd.avg_devs ELSE NULL END),0) AS avg_devs_this_year,
        COALESCE(AVG(CASE WHEN yd.year = DATE_TRUNC(YEAR, CURRENT_DATE() - INTERVAL '1 year') THEN yd.avg_devs ELSE NULL END),0) AS avg_devs_last_year
      FROM yearly_devs yd
      GROUP BY 1
    )
    SELECT
      e.*,
      pm.avg_devs_this_year,
      pm.avg_devs_last_year
    FROM events e
    LEFT JOIN project_metrics pm
    ON e.to_oso_project_id = pm.project_id

    """)
    df_venture['time'] = pd.to_datetime(df_venture['time'])

    _investor_counts = df_venture.groupby('from_investor_name')['event_id'].nunique().sort_values(ascending=False)
    _min_investor_portfolio_size = 5
    _investor_counts = _investor_counts[_investor_counts >= _min_investor_portfolio_size]
    investor_list = list(_investor_counts.index)
    return df_venture, investor_list


@app.cell
def configuration_settings(datetime, investor_list, mo):
    start_date_input = mo.ui.date(
        label="Start Date",
        value="2020-01-01",
    )
    end_date_input = mo.ui.date(
        label="End Date", 
        value=datetime.date.today(),
    )
    investor_input = mo.ui.dropdown(
        options=investor_list,
        value="Paradigm",
        label="Choose an Investor"
    )
    mo.vstack([
        mo.md("### Configuration"),
        mo.hstack([investor_input, start_date_input, end_date_input], widths="equal", gap=1),
    ])
    return end_date_input, investor_input, start_date_input


@app.cell
def _(df_venture, end_date_input, investor_input, pd, start_date_input):
    _deal_ids = df_venture[
        (df_venture['from_investor_name'] == investor_input.value)
        & (df_venture['time'] >= pd.to_datetime(start_date_input.value))
        & (df_venture['time'] <= pd.to_datetime(end_date_input.value))
        & (df_venture['event_type'] == 'LED_INVESTMENT_ROUND')
    ]['event_id'].to_list()

    _cols = ['time', 'to_company_name', 'to_oso_project_name', 'amount_raised', 'num_investors', 'avg_devs_this_year', 'avg_devs_last_year']
    df_portfolio = (
        df_venture[
            (df_venture['event_id'].isin(_deal_ids))
            & (df_venture['event_type'] == 'INVESTMENT_RECEIVED')
        ]
        .sort_values(by='amount_raised', ascending=False)
        .drop_duplicates(subset=['to_company_name', 'funding_round_name', 'amount_raised'], keep='first')
        .reset_index(drop=True)
        .copy()
        [_cols]
    )
    return (df_portfolio,)


@app.cell
def generate_stats(df_portfolio, mo):
    total_investments = mo.stat(
        label="Total Investments",
        bordered=True,
        value=f"{len(df_portfolio):,.0f}",
    )

    total_companies = mo.stat(
        label="Total Companies",
        bordered=True,
        value=f"{df_portfolio['to_company_name'].nunique():,.0f}",
    )

    avg_funding = mo.stat(
        label="Average Raise",
        bordered=True,
        value=f"${df_portfolio['amount_raised'].mean():,.0f}",
    )

    max_funding = mo.stat(
        label="Largest Raise", 
        bordered=True,
        value=f"${df_portfolio['amount_raised'].max():,.0f}",
    )

    total_funding = mo.stat(
        label="Total Funding",
        bordered=True,
        value=f"${df_portfolio['amount_raised'].sum():,.0f}",
    )

    mo.hstack(
        [total_investments, total_companies, avg_funding, max_funding, total_funding],
        widths="equal",
        gap=1,
    )
    return


@app.cell
def generate_table(df_portfolio, mo, pd):
    def categorize_team_growth(row):
        this_year = row['avg_devs_this_year']
        last_year = row['avg_devs_last_year']

        # No data if both years are null
        if pd.isna(this_year) and pd.isna(last_year):
            return 'â“ No Data'

        if this_year < 0.2:
            return 'ðŸ’€ Potentially Dead'

        # No data if we only have this year but no last year for comparison
        if (not pd.isna(this_year) and this_year > 0) and pd.isna(last_year):
            return 'â“ No Data'

        # Calculate growth rate
        if pd.isna(last_year) or last_year == 0:
            return 'â“ No Data'

        growth_rate = (this_year - last_year) / last_year

        if growth_rate >= 0.5:  # 50%+ growth
            return 'ðŸš€ Fast Growing'
        elif growth_rate <= -0.5:  # Below -50%
            return 'ðŸ“‰ Shrinking'
        else:
            return 'ðŸ“ˆ Steady'

    display_df = (
        df_portfolio.copy()
        .assign(
            funding_date=lambda d: d['time'].dt.strftime('%Y-%m-%d'),
            tracked_by_oso=lambda d: d['to_oso_project_name'].notna(),
            team_status=lambda d: d.apply(categorize_team_growth, axis=1)
        )
        .rename(columns={
            'funding_date': 'Date',
            'to_company_name': 'Company Name',
            'amount_raised': 'Amount Raised',
            'num_investors': 'Num Investors',
            'tracked_by_oso': 'Company in OSO?',
            'avg_devs_this_year': 'Developers (This Year)',
            'avg_devs_last_year': 'Developers (Last Year)',
            'team_status': 'Team Status'
        })
        .drop(columns=['to_oso_project_name', 'time'])
        .sort_values(by='Amount Raised', ascending=False)
        .reset_index(drop=True)
        [['Company Name', 'Amount Raised', 'Num Investors', 'Date', 'Company in OSO?', 'Developers (This Year)', 'Developers (Last Year)', 'Team Status']]
    )

    mo.ui.table(
        display_df,
        format_mapping={
            'Amount Raised': '${:,.0f}',
            'Developers (This Year)': '{:,.1f}',
            'Developers (Last Year)': '{:,.1f}',
        },
        selection=None,
        show_column_summaries=False,
        show_data_types=False,
        page_size=10
    )
    return


@app.cell
def generate_plots(df_portfolio, go, mo, pd, px):
    def make_empty_fig(title=""):
        fig = go.Figure()
        fig.update_layout(
            paper_bgcolor="white",
            plot_bgcolor="white",
            font=dict(size=12, color="#111"),
            title=dict(text=title, x=0, xanchor="left"),
            margin=dict(t=50, l=20, r=20, b=20),
            annotations=[dict(
                x=0.5, y=0.5,
                xref="paper", yref="paper",
                text="No data available",
                showarrow=False,
                font=dict(size=14, color="#666")
            )]
        )
        return fig

    # 1. Bar chart of funding amount by year
    def make_yearly_bar(dataframe):
        if len(dataframe) == 0:
            return make_empty_fig("Funding by Year")

        yearly_funding = (
            dataframe.groupby(dataframe['time'].dt.year)['amount_raised']
            .sum()
            .reset_index()
            .rename(columns={'time': 'year', 'amount_raised': 'total_funding'})
        )

        fig = px.bar(
            yearly_funding,
            x='year',
            y='total_funding',
            title="<b>Funding by Year</b>",
            color_discrete_sequence=['#666666']
        )

        fig.update_layout(
            paper_bgcolor="white",
            plot_bgcolor="white",
            font=dict(size=12, color="#111"),
            title=dict(x=0, xanchor="left"),
            margin=dict(t=50, l=20, r=20, b=20),
            showlegend=False
        )

        fig.update_xaxes(showgrid=False, linecolor="#000", ticks="outside", title = None)
        fig.update_yaxes(
            showgrid=True, 
            gridcolor="#DDD", 
            linecolor="#000", 
            ticks="outside",
            tickprefix="$",
            tickformat=",.2s",
            title = None
        )

        fig.update_traces(
            hovertemplate="<b>%{x}</b><br>Total Funding: $%{y:,.2s}<extra></extra>"
        )

        return fig

    # 2. Area chart of cumulative funding over time
    def make_cumulative_area(dataframe):
        if len(dataframe) == 0:
            return make_empty_fig("Cumulative Funding")

        # Sort by time and calculate cumulative sum
        cumulative_data = (
            dataframe.sort_values('time')
            .assign(cumulative_funding=lambda d: d['amount_raised'].cumsum())
            [['time', 'cumulative_funding']]
        )

        # Create a continuous date range to fill gaps
        start_date = cumulative_data['time'].min()
        end_date = cumulative_data['time'].max()
        date_range = pd.date_range(start=start_date, end=end_date, freq='D')

        # Create a DataFrame with all dates and forward-fill cumulative values
        continuous_data = pd.DataFrame({'time': date_range})
        continuous_data = continuous_data.merge(cumulative_data, on='time', how='left')
        continuous_data['cumulative_funding'] = continuous_data['cumulative_funding'].ffill().fillna(0)

        fig = px.area(
            continuous_data,
            x='time',
            y='cumulative_funding',
            title="<b>Cumulative Funding</b>",
            color_discrete_sequence=['#666666']
        )

        fig.update_layout(
            paper_bgcolor="white",
            plot_bgcolor="white",
            font=dict(size=12, color="#111"),
            title=dict(x=0, xanchor="left"),
            margin=dict(t=50, l=20, r=20, b=20),
            showlegend=False
        )

        fig.update_xaxes(showgrid=False, linecolor="#000", ticks="outside", title = None)
        fig.update_yaxes(
            showgrid=True, 
            gridcolor="#DDD", 
            linecolor="#000", 
            ticks="outside",
            tickprefix="$",
            tickformat=",.2s",
            title = None
        )

        # Add smoothing to the line
        fig.update_traces(
            hovertemplate="<b>%{x|%Y-%m-%d}</b><br>Cumulative: $%{y:,.2s}<extra></extra>",
            line=dict(smoothing=1.3, shape='spline')
        )

        return fig

    # 3. Histogram of funding amount bins
    def make_funding_histogram(dataframe):
        if len(dataframe) == 0:
            return make_empty_fig("Funding Distribution")

        # Create funding bins with proper ordering
        def categorize_funding(amount):
            if amount < 3_000_000:
                return "Less than 3M"
            elif amount < 10_000_000:
                return "3M to 10M"
            elif amount < 30_000_000:
                return "10M to 30M"
            elif amount < 100_000_000:
                return "30M to 100M"
            else:
                return "100M+"

        # Define the order for proper sorting by deal size
        bin_order = ["Less than 3M", "3M to 10M", "10M to 30M", "30M to 100M", "100M+"]

        funding_bins = (
            dataframe.assign(funding_bin=lambda d: d['amount_raised'].apply(categorize_funding))
            .groupby('funding_bin')
            .size()
            .reset_index(name='count')
        )

        # Sort by deal size order, not by count
        funding_bins['bin_order'] = funding_bins['funding_bin'].map({bin_name: i for i, bin_name in enumerate(bin_order)})
        funding_bins = funding_bins.sort_values('bin_order').drop('bin_order', axis=1)

        fig = px.bar(
            funding_bins,
            x='count',
            y='funding_bin',
            orientation='h',
            title="<b>Funding Distribution</b>",
            color_discrete_sequence=['#666666']
        )

        fig.update_layout(
            paper_bgcolor="white",
            plot_bgcolor="white",
            font=dict(size=12, color="#111"),
            title=dict(x=0, xanchor="left"),
            margin=dict(t=50, l=20, r=20, b=20),
            showlegend=False
        )

        fig.update_xaxes(showgrid=False, linecolor="#000", ticks="outside", title = None)
        fig.update_yaxes(showgrid=True, gridcolor="#DDD", linecolor="#000", ticks="outside", title = None)

        fig.update_traces(
            hovertemplate="<b>%{y}</b><br>Count: %{x}<extra></extra>"
        )

        return fig

    fig1 = make_yearly_bar(df_portfolio)
    fig2 = make_cumulative_area(df_portfolio)
    fig3 = make_funding_histogram(df_portfolio)

    mo.hstack(
        items=[
            mo.ui.plotly(fig1),
            mo.ui.plotly(fig2),
            mo.ui.plotly(fig3),
        ], 
        widths="equal",
        gap=1
    )
    return


@app.cell
def _(df_portfolio, mo):
    # Get companies that are tracked in OSO (have to_oso_project_name)
    oso_companies = (
        df_portfolio[df_portfolio['to_oso_project_name'].notna()]
        [['to_company_name', 'to_oso_project_name']]
        .drop_duplicates()
        .sort_values('to_company_name')
    )

    # Create a mapping from company name to OSO project name
    company_to_project = dict(zip(oso_companies['to_company_name'], oso_companies['to_oso_project_name']))

    project_dropdown = mo.ui.dropdown(
        label="Select a Company",
        options=list(company_to_project.keys()),
        value=list(company_to_project.keys())[0] if company_to_project else None,
        searchable=True,
        full_width=True
    )

    mo.vstack([
        mo.md("## Project Deep Dive"),
        project_dropdown
    ])
    return company_to_project, project_dropdown


@app.cell
def get_project_developer_data(client, company_to_project, project_dropdown):
    # Get the OSO project name for the selected company
    selected_oso_project = company_to_project.get(project_dropdown.value, '')

    _query = f"""
    WITH project_lookup AS (
      SELECT DISTINCT to_oso_project_id as project_id
      FROM int_events__coresignal_venture
      WHERE to_oso_project_name = '{selected_oso_project}'
    ),
    developer_metrics AS (
      SELECT
        sample_date,
        amount as active_developers
      FROM timeseries_metrics_by_project_v0
      JOIN project_lookup USING (project_id)
      JOIN metrics_v0 USING (metric_id)
      WHERE metric_name = 'GITHUB_active_developers_monthly'
        AND sample_date >= DATE('2020-01-01')
    ),
    funding_events AS (
      SELECT
        DATE_TRUNC('month', time) AS sample_date,
        MAX(amount_raised) AS funding_amount
      FROM int_events__coresignal_venture
      WHERE to_oso_project_name = '{selected_oso_project}'
        AND event_type = 'INVESTMENT_RECEIVED'
      GROUP BY 1
    ),
    combined_data AS (
      SELECT
        COALESCE(d.sample_date, f.sample_date) AS sample_date,
        COALESCE(d.active_developers, 0) AS active_developers,
        COALESCE(f.funding_amount, 0) AS funding_amount
      FROM developer_metrics d
      FULL OUTER JOIN funding_events f ON d.sample_date = f.sample_date
    )
    SELECT * FROM combined_data
    ORDER BY sample_date
    """

    df_project_data = client.to_pandas(_query)
    return (df_project_data,)


@app.cell
def generate_project_timeseries_plot(
    df_project_data,
    go,
    mo,
    project_dropdown,
):
    def make_project_developer_fig(dataframe, project_name):
        if len(dataframe) == 0:
            fig = go.Figure()
            fig.update_layout(
                paper_bgcolor="white",
                plot_bgcolor="white",
                font=dict(size=12, color="#111"),
                title=dict(text=f"<b>{project_name} Developer Activity</b>", x=0, xanchor="left"),
                margin=dict(t=50, l=20, r=20, b=20),
                annotations=[dict(
                    x=0.5, y=0.5,
                    xref="paper", yref="paper",
                    text="No data available",
                    showarrow=False,
                    font=dict(size=16, color="#666")
                )]
            )
            return fig

        # Create the main developer activity line
        fig = go.Figure()

        # Add developer activity line
        fig.add_trace(go.Scatter(
            x=dataframe['sample_date'],
            y=dataframe['active_developers'],
            mode='lines+markers',
            name='Active Developers',
            line=dict(color='#666666', width=2),
            marker=dict(size=4),
            hovertemplate="<b>%{x|%b %Y}</b><br>Developers: %{y:.1f}<extra></extra>"
        ))

        # Add funding events as vertical lines with annotations
        funding_events = dataframe[dataframe['funding_amount'] > 0]
        if len(funding_events) > 0:
            shapes = []
            annotations = []

            for _, row in funding_events.iterrows():
                funding_date = row['sample_date']
                funding_amount = row['funding_amount'] / 1_000_000  # Convert to millions

                # Add vertical line
                shapes.append(dict(
                    type='line',
                    x0=funding_date,
                    x1=funding_date,
                    y0=0,
                    y1=1,
                    yref='paper',
                    line=dict(color='black', width=1, dash='dash')
                ))

                # Add annotation
                annotations.append(dict(
                    x=funding_date,
                    y=0.95,
                    xref='x',
                    yref='paper',
                    text=f"${funding_amount:.1f}M",
                    showarrow=False,
                    textangle=0,
                    yanchor='top',
                    bgcolor='rgba(255,255,255,1.0)',
                    bordercolor='black',
                    borderwidth=1
                ))

            fig.update_layout(shapes=shapes, annotations=annotations)

        fig.update_layout(
            paper_bgcolor="white",
            plot_bgcolor="white",
            font=dict(size=12, color="#111"),
            title=dict(text=f"<b>{project_name} Developer Activity</b>", x=0, xanchor="left"),
            margin=dict(t=50, l=20, r=20, b=20),
            showlegend=False,
            height=400
        )

        fig.update_xaxes(
            title="Date",
            showgrid=False,
            linecolor="#000",
            ticks="outside"
        )

        fig.update_yaxes(
            title="Active Developers",
            showgrid=True,
            gridcolor="#DDD",
            linecolor="#000",
            ticks="outside"
        )

        return fig

    _fig = make_project_developer_fig(df_project_data, project_dropdown.value or "Selected Company")
    mo.ui.plotly(_fig)
    return


@app.cell
def import_libraries():
    import datetime
    import pandas as pd
    import plotly.express as px
    import plotly.graph_objects as go
    return datetime, go, pd, px


if __name__ == "__main__":
    app.run()
